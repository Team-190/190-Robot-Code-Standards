"use strict";(self.webpackChunkcode_standard=self.webpackChunkcode_standard||[]).push([[261],{4825:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>l,frontMatter:()=>r,metadata:()=>o,toc:()=>m});const o=JSON.parse('{"id":"COMMANDS_STANDARDS","title":"Command Standards","description":"Subsystem Commands","source":"@site/docs/COMMANDS_STANDARDS.md","sourceDirName":".","slug":"/COMMANDS_STANDARDS","permalink":"/190-Robot-Code-Standards/COMMANDS_STANDARDS","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Subsystem Standards","permalink":"/190-Robot-Code-Standards/SUBSYSTEM_STANDARDS"},"next":{"title":"Control Loop Standards","permalink":"/190-Robot-Code-Standards/CONTROL_LOOP_STANDARDS"}}');var a=t(4848),s=t(8453);const r={},i="Command Standards",d={},m=[{value:"Subsystem Commands",id:"subsystem-commands",level:2},{value:"Subsystem Command Exceptions",id:"subsystem-command-exceptions",level:2},{value:"Composite Commands",id:"composite-commands",level:2},{value:"Button Bindings and Triggers",id:"button-bindings-and-triggers",level:2},{value:"Autonomous Routines",id:"autonomous-routines",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"command-standards",children:"Command Standards"})}),"\n",(0,a.jsx)(n.h2,{id:"subsystem-commands",children:"Subsystem Commands"}),"\n",(0,a.jsx)(n.p,{children:"In order for a subsystem to be useful, they must be told to do something, this is what commands are for. Subsystems tell the actuators how to do something (ex. run at a voltage, follow a motion profile, account for feedback, etc.) while commands tell the robot to actually execute the tasks."}),"\n",(0,a.jsx)(n.p,{children:"Simple commands that only require one subsystem are located in that subsystem."}),"\n",(0,a.jsx)(n.p,{children:"Example: Running a motor at a velocity"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"public Command runVelocity() {\n    return runEnd(\n        () -> {\n          setSpinVelocity(SubsystemConstants.DEFAULT_SPEED.get());\n        },\n        () -> {\n          setSpinVelocity(0.0);\n        });\n  }\n"})}),"\n",(0,a.jsx)(n.p,{children:"These commands can be used in other places in the robot code by referencing the subsystem."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"subsystem.runVelocity();\n"})}),"\n",(0,a.jsx)(n.h2,{id:"subsystem-command-exceptions",children:"Subsystem Command Exceptions"}),"\n",(0,a.jsx)(n.p,{children:"In long and complicated subsystems that have a lot of logic, it can be useful to separate commands into a different class to improve code readibility."}),"\n",(0,a.jsxs)(n.p,{children:["Example: ",(0,a.jsx)(n.a,{href:"https://github.com/Team-190/2k24-Robot-Code/blob/main/src/main/java/frc/robot/commands/DriveCommands.java",children:"DriveCommands.java"})," from FRC 190 2024 robots"]}),"\n",(0,a.jsx)(n.h2,{id:"composite-commands",children:"Composite Commands"}),"\n",(0,a.jsxs)(n.p,{children:["Composite commands are commands that are made up of more than one pre-defined command. They always take the form of a static factory. In general, composite commands should never be their own classes. ",(0,a.jsx)(n.a,{href:"https://github.com/wpilibsuite/allwpilib",children:"WPIlib"})," has excellent documentation on ",(0,a.jsx)(n.a,{href:"https://docs.wpilib.org/en/stable/docs/software/commandbased/command-compositions.html",children:"Command Composition"})," as well as ",(0,a.jsx)(n.a,{href:"https://docs.wpilib.org/en/2020/docs/software/commandbased/convenience-features.html",children:"Command Decorators"})," which are much more intuitive and concise."]}),"\n",(0,a.jsx)(n.p,{children:"It is generally best to write commands as compositions rather than string commands together with decorators."}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"public static final Command getCollectCommand(Intake intake, Serializer serializer) {\n    return Commands.sequence(\n        intake.deployIntake(),\n        Commands.race(intake.runVoltage(), serializer.intake()),\n        intake.retractIntake());\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"instead of"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"public static final Command getCollectCommand(Intake intake, Serializer serializer) {\n    return\n        intake.deployIntake()\n        .andThen(Commands.race(intake.runVoltage(), serializer.intake()))\n        .andThen(intake.retractIntake());\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Composite commands reside in their own class called ",(0,a.jsx)(n.code,{children:"CompositeCommands.java"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Example: ",(0,a.jsx)(n.a,{href:"https://github.com/Team-190/2k24-Robot-Code/blob/main/src/main/java/frc/robot/commands/CompositeCommands.java",children:"CompositeCommands.java"})," from FRC 190 2024 robots"]}),"\n",(0,a.jsx)(n.h2,{id:"button-bindings-and-triggers",children:"Button Bindings and Triggers"}),"\n",(0,a.jsxs)(n.p,{children:["Commands tell the robot to execute tasks, but in order for the robot code to schedule the command for execution, it needs to be bound to a ",(0,a.jsx)(n.a,{href:"https://docs.wpilib.org/en/stable/docs/software/commandbased/binding-commands-to-triggers.html",children:"Trigger"}),". Triggers tell the robot which conditions need to be met to execute commands. Triggers are always instantiated in the ",(0,a.jsx)(n.code,{children:"configureButtonBindings()"})," method of ",(0,a.jsx)(n.code,{children:"RobotContainer.java"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Example: Shooting a game piece"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"driver\n        .rightBumper()\n        .and(() -> RobotState.shooterReady(hood, shooter))\n        .whileTrue(\n            Commands.waitSeconds(0.25)\n                .andThen(CompositeCommands.getShootCommand(intake, serializer, kicker)));\n"})}),"\n",(0,a.jsxs)(n.p,{children:["in this case, ",(0,a.jsx)(n.code,{children:"rightBumper()"})," is the trigger representing the right bumper button on the driver's Xbox 360 controller. The ",(0,a.jsx)(n.code,{children:".and()"})," call adds another condition to the trigger. The ",(0,a.jsx)(n.code,{children:".whileTrue()"})," call means that the robot trigger will only run the command while the conditions of the trigger are met. This trigger made the robot only able to shoot when the driver pressed the right bumper and when the robot code reported the shooter was ready to fire."]}),"\n",(0,a.jsx)(n.p,{children:"It is worth noting that Triggers can be arbitrary by creating a new Trigger object and binding it to an event, which can then be passed into a command as a parameter."}),"\n",(0,a.jsx)(n.p,{children:"Example: An arbitrary trigger"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"Trigger arbitraryTrigger = new Trigger(limitSwitch::get)\n"})}),"\n",(0,a.jsx)(n.p,{children:"However, this usually isn't necessary because required subsystems get passed into composite commands, meaning there usually isn't a reason to bind command to a trigger unless it's being bound to a button."}),"\n",(0,a.jsx)(n.p,{children:"Arbitrary Triggers are most useful when a condition must be met across a wide number of commands."}),"\n",(0,a.jsx)(n.p,{children:"Example: Shooting a game piece using a trigger."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"Trigger shooterReady = new Trigger(() -> RobotState.shooterReady(hood, shooter))\n\ndriver\n        .rightBumper()\n        .and(shooterReady)\n        .whileTrue(\n            Commands.waitSeconds(0.25)\n                .andThen(CompositeCommands.getShootCommand(intake, serializer, kicker)));\n"})}),"\n",(0,a.jsx)(n.h2,{id:"autonomous-routines",children:"Autonomous Routines"}),"\n",(0,a.jsx)(n.p,{children:"Autonomous routines are simply composite command that are called during autonomous. Autonomous paths are loaded into the roborio when the code is deployed, and called during the autonomous period. We can follow a path using its path on the roborio."}),"\n",(0,a.jsx)(n.p,{children:"Example: Center Two Piece autonomous routine from FRC 190 2024 robots"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'public static final Command centerTwoPiece(\n      Drive drive, Intake intake, Serializer serializer, Kicker kicker, TrackingMode targetType) {\n    return Commands.sequence(\n        AutoBuilder.followPath(PathPlannerPath.fromPathFile("deploy/paths/Center to Center Wing Note")),\n        CompositeCommands.getAimSpeakerCommand(drive),\n        CompositeCommands.getShootCommand(intake, serializer, kicker),\n        CompositeCommands.getTrackNoteSpikeCommand(\n            drive, intake, serializer, AutoPathPoints.NOTE_2, targetType),\n        CompositeCommands.getAimSpeakerCommand(drive),\n        CompositeCommands.getShootCommand(intake, serializer, kicker));\n      }\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"danger",children:(0,a.jsxs)(n.p,{children:["This autonomous routine may not be correct, as it uses Pathplanner rather than Choreo, if using this as a reference, do not use the ",(0,a.jsx)(n.code,{children:"AutoBuilder"})," class if not using Pathplanner."]})})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var o=t(6540);const a={},s=o.createContext(a);function r(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);