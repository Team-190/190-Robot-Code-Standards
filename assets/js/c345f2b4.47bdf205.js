"use strict";(self.webpackChunkcode_standard=self.webpackChunkcode_standard||[]).push([[266],{2821:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"ROBOTSTATE_STANDARDS","title":"Robot State Standards","description":"The `RobotState.java` class is used for multiple things:","source":"@site/docs/ROBOTSTATE_STANDARDS.md","sourceDirName":".","slug":"/ROBOTSTATE_STANDARDS","permalink":"/190-Robot-Code-Standards/ROBOTSTATE_STANDARDS","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Logger Standards","permalink":"/190-Robot-Code-Standards/LOGGING_STANDARDS"},"next":{"title":"Constants Standards","permalink":"/190-Robot-Code-Standards/CONSTANTS_STANDARDS"}}');var a=o(4848),i=o(8453);const r={},s="Robot State Standards",l={},d=[{value:"Constructing RobotState.java",id:"constructing-robotstatejava",level:2},{value:"Interpolation Maps and Shot Compensation",id:"interpolation-maps-and-shot-compensation",level:2},{value:"Periodic Pose Estimation and ControlData",id:"periodic-pose-estimation-and-controldata",level:2},{value:"Example",id:"example",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"robot-state-standards",children:"Robot State Standards"})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"RobotState.java"})," class is used for multiple things:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Localization"}),"\n",(0,a.jsx)(t.li,{children:"Global variable mutation"}),"\n",(0,a.jsx)(t.li,{children:"Interpolation maps"}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Essentially, anything that is required by more than one subsystem, goes in ",(0,a.jsx)(t.code,{children:"RobotState.java"})]}),"\n",(0,a.jsx)(t.h2,{id:"constructing-robotstatejava",children:"Constructing RobotState.java"}),"\n",(0,a.jsxs)(t.p,{children:["One of the purposes of ",(0,a.jsx)(t.code,{children:"RobotState.java"})," is to combine odometry and vision data to get a more accurate estimated robot pose. This is done by passing data into the ",(0,a.jsx)(t.code,{children:"RobotState.java"})," periodic method:"]}),"\n",(0,a.jsx)(t.p,{children:"Example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-java",children:"public static void periodic(\n      Rotation2d robotHeading,\n      long latestRobotHeadingTimestamp,\n      double robotYawVelocity,\n      Translation2d robotFieldRelativeVelocity,\n      SwerveModulePosition[] modulePositions,\n      Camera[] cameras,\n      boolean hasNoteLocked,\n      boolean hasNoteStaged,\n      boolean isIntaking) {\n\n    RobotState.robotHeading = robotHeading;\n    RobotState.modulePositions = modulePositions;\n\n    odometry.update(robotHeading, modulePositions);\n    poseEstimator.updateWithTime(Timer.getFPGATimestamp(), robotHeading, modulePositions);\n\n    for (Camera camera : cameras) {\n      double[] limelightHeadingData = {\n        robotHeading.minus(headingOffset).getDegrees(), 0.0, 0.0, 0.0, 0.0, 0.0\n      };\n      camera.getRobotHeadingPublisher().set(limelightHeadingData, latestRobotHeadingTimestamp);\n    }\n    NetworkTableInstance.getDefault().flush();\n    for (Camera camera : cameras) {\n\n      if (camera.getTargetAquired()\n          && !GeometryUtil.isZero(camera.getPrimaryPose())\n          && !GeometryUtil.isZero(camera.getSecondaryPose())\n          && Math.abs(robotYawVelocity) <= Units.degreesToRadians(15.0)\n          && Math.abs(robotFieldRelativeVelocity.getNorm()) <= 1.0) {\n        double xyStddevPrimary =\n            camera.getPrimaryXYStandardDeviationCoefficient()\n                * Math.pow(camera.getAverageDistance(), 2.0)\n                / camera.getTotalTargets()\n                * camera.getHorizontalFOV();\n        poseEstimator.addVisionMeasurement(\n            camera.getPrimaryPose(),\n            camera.getFrameTimestamp(),\n            VecBuilder.fill(xyStddevPrimary, xyStddevPrimary, Double.POSITIVE_INFINITY));\n        if (camera.getTotalTargets() > 1) {\n          double xyStddevSecondary =\n              camera.getSecondaryXYStandardDeviationCoefficient()\n                  * Math.pow(camera.getAverageDistance(), 2.0)\n                  / camera.getTotalTargets()\n                  * camera.getHorizontalFOV();\n          poseEstimator.addVisionMeasurement(\n              camera.getSecondaryPose(),\n              camera.getFrameTimestamp(),\n              VecBuilder.fill(xyStddevSecondary, xyStddevSecondary, Double.POSITIVE_INFINITY));\n        }\n      }\n    }\n\n\n    ...\n"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"periodic()"})," should be called in ",(0,a.jsx)(t.code,{children:"RobotContainer.java"})," just before the button bindings are configured:"]}),"\n",(0,a.jsx)(t.p,{children:"Example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-java",children:"...\n\npublic void robotPeriodic() {\n    RobotState.periodic(\n        drive.getRawGyroRotation(),\n        NetworkTablesJNI.now(),\n        drive.getYawVelocity(),\n        drive.getFieldRelativeVelocity(),\n        drive.getModulePositions(),\n        vision.getCameras(),\n        false,\n        false,\n        false);\n\n        ...\n}\n\n...\n"})}),"\n",(0,a.jsx)(t.h2,{id:"interpolation-maps-and-shot-compensation",children:"Interpolation Maps and Shot Compensation"}),"\n",(0,a.jsxs)(t.p,{children:["For shooting games, interpolating hoods and flywheels are very important to dynamically adjust the robot's shot. This is all done in ",(0,a.jsx)(t.code,{children:"RobotState.java"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"All interpolation map values are added in a static block:"}),"\n",(0,a.jsx)(t.p,{children:"Example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-java",children:"static {\n    // Units: radians per second\n    shooterSpeedMap.put(2.16, 800.0);\n    shooterSpeedMap.put(2.45, 800.0);\n    shooterSpeedMap.put(2.69, 800.0);\n    shooterAngleMap.put(2.84, 800.0);\n    shooterSpeedMap.put(3.19, 800.0);\n    shooterSpeedMap.put(3.52, 800.0);\n    shooterSpeedMap.put(3.85, 900.0);\n    shooterSpeedMap.put(4.29, 900.0);\n\n    // Units: radians\n    shooterAngleMap.put(2.16, 0.05);\n    shooterAngleMap.put(2.45, 0.05);\n    shooterAngleMap.put(2.69, 0.16);\n    shooterAngleMap.put(2.84, 0.32);\n    shooterAngleMap.put(3.19, 0.39);\n    shooterAngleMap.put(3.52, 0.45);\n    shooterAngleMap.put(3.85, 0.44);\n    shooterAngleMap.put(4.29, 0.45);\n\n    // Units: seconds\n    timeOfFlightMap.put(2.50, (4.42 - 4.24));\n    timeOfFlightMap.put(2.75, (2.56 - 2.33));\n    timeOfFlightMap.put(3.00, (3.43 - 3.18));\n    timeOfFlightMap.put(3.25, (3.20 - 2.94));\n    timeOfFlightMap.put(3.50, (2.64 - 2.42));\n    timeOfFlightMap.put(4.0, (2.60 - 2.32));\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:'Because of the 1/2" field tolerance, each FRC field can be different, therefore it is paramount that there be a method for adjusting shots on the fly.'}),"\n",(0,a.jsx)(t.p,{children:"Example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-java",children:"@Getter @Setter private static double flywheelOffset = 0.0;\n@Getter @Setter private static double hoodOffset = 0.0;\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The variables can then be changed using a Command in ",(0,a.jsx)(t.code,{children:"CompositeCommands.java"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-java",children:"public static Command increaseFlywheelVelocity() {\n    return Commands.runOnce(() -> RobotState.setFlywheelOffset(RobotState.getFlywheelOffset() + 10));\n  }\n\npublic static Command decreaseFlywheelVelocity() {\n    return Commands.runOnce(() -> RobotState.setFlywheelOffset(RobotState.getFlywheelOffset() - 10));\n}\n\npublic static Command increaseHoodAngle() {\n    return Commands.runOnce(() -> RobotState.setHoodOffset(RobotState.getHoodOffset() + Units.degreesToRadians(0.25)));\n}\n\npublic static Command decreaseHoodAngle() {\n    return Commands.runOnce(() -> RobotState.setHoodOffset(RobotState.getHoodOffset() - Units.degreesToRadians(0.25)));\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["And bound to a button in ",(0,a.jsx)(t.code,{children:"RobotContainer.java"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-java",children:"operator.y().whileTrue(CompositeCommands.increaseFlywheelVelocity());\noperator.a().whileTrue(CompositeCommands.decreaseFlywheelVelocity());\noperator.leftBumper().onTrue(CompositeCommands.decreaseHoodAngle());\noperator.leftTrigger().onTrue(CompositeCommands.increaseHoodAngle());\n"})}),"\n",(0,a.jsx)(t.h2,{id:"periodic-pose-estimation-and-controldata",children:"Periodic Pose Estimation and ControlData"}),"\n",(0,a.jsxs)(t.p,{children:["Periodically on the robot, the ",(0,a.jsx)(t.code,{children:"RobotState.java"})," class takes all the information in from its suppliers, and calculates everything the robot needs to know. For example, in a shooting game:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Hood Angle"}),"\n",(0,a.jsx)(t.li,{children:"Flywheel Speed"}),"\n",(0,a.jsx)(t.li,{children:"Effective Aiming Pose (for shooting on the move)"}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["This data is calculated, and stored in a record called ",(0,a.jsx)(t.code,{children:"ControlData"}),":"]}),"\n",(0,a.jsx)(t.p,{children:"Example: ControlData record for FRC 190 2024 robots"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-java",children:"public static record ControlData(\n      Rotation2d speakerRobotAngle,\n      double speakerRadialVelocity,\n      Rotation2d speakerArmAngle,\n      FlywheelSpeeds speakerShotSpeed,\n      double ampRadialVelocity,\n      Rotation2d feedRobotAngle,\n      double feedRadialVelocity,\n      Rotation2d feedArmAngle,\n      FlywheelSpeeds feedShotSpeed,\n      boolean hasNoteLocked,\n      boolean hasNoteStaged,\n      boolean isIntaking) {}\n"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"RobotState.java"})," contains an instance of ",(0,a.jsx)(t.code,{children:"ControlData"})," as a member variable, which is updated in the periodic method, along with the pose estimator:"]}),"\n",(0,a.jsx)(t.p,{children:"Example: ControlData update for FRC 190 2024 robots"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-java",children:'Translation2d speakerPose =\n        AllianceFlipUtil.apply(FieldConstants.Speaker.centerSpeakerOpening.toTranslation2d());\n    double distanceToSpeaker =\n        poseEstimator.getEstimatedPosition().getTranslation().getDistance(speakerPose);\n    Translation2d effectiveSpeakerAimingTranslation =\n        poseEstimator\n            .getEstimatedPosition()\n            .getTranslation()\n            .plus(robotFieldRelativeVelocity.times(timeOfFlightMap.get(distanceToSpeaker)));\n    double effectiveDistanceToSpeaker = effectiveSpeakerAimingTranslation.getDistance(speakerPose);\n\n    Translation2d ampPose = AllianceFlipUtil.apply(FieldConstants.ampCenter);\n    double distanceToAmp =\n        poseEstimator.getEstimatedPosition().getTranslation().getDistance(ampPose);\n    Translation2d effectiveAmpAimingTranslation =\n        poseEstimator\n            .getEstimatedPosition()\n            .getTranslation()\n            .plus(robotFieldRelativeVelocity.times(timeOfFlightMap.get(distanceToAmp)));\n    double effectiveDistanceToAmp = effectiveAmpAimingTranslation.getDistance(ampPose);\n\n    Rotation2d speakerRobotAngle =\n        speakerPose\n            .minus(effectiveSpeakerAimingTranslation)\n            .getAngle()\n            .minus(Rotation2d.fromDegrees(180.0 + 3.5));\n    double speakerTangentialVelocity =\n        -robotFieldRelativeVelocity.rotateBy(speakerRobotAngle.unaryMinus()).getY();\n    double speakerRadialVelocity = speakerTangentialVelocity / effectiveDistanceToSpeaker;\n\n    Rotation2d ampRobotAngle =\n        ampPose.minus(effectiveAmpAimingTranslation).getAngle().minus(Rotation2d.fromDegrees(90.0));\n    double ampTangentialVelocity =\n        -robotFieldRelativeVelocity.rotateBy(ampRobotAngle.unaryMinus()).getY();\n    double ampRadialVelocity = ampTangentialVelocity / effectiveDistanceToAmp;\n\n    Rotation2d feedRobotAngle =\n        ampPose\n            .minus(effectiveAmpAimingTranslation)\n            .getAngle()\n            .minus(Rotation2d.fromDegrees(180.0));\n    double feedTangentialVelocity =\n        -robotFieldRelativeVelocity.rotateBy(feedRobotAngle.unaryMinus()).getY();\n    double feedRadialVelocity = feedTangentialVelocity / effectiveDistanceToAmp;\n\n    controlData =\n        new ControlData(\n            speakerRobotAngle,\n            speakerRadialVelocity,\n            new Rotation2d(speakerShotAngleMap.get(effectiveDistanceToSpeaker)),\n            speakerShotSpeedMap.get(effectiveDistanceToSpeaker),\n            ampRadialVelocity,\n            feedRobotAngle,\n            feedRadialVelocity,\n            new Rotation2d(feedShotAngleMap.get(effectiveDistanceToAmp)),\n            feedShotSpeedMap.get(effectiveDistanceToAmp),\n            hasNoteLocked,\n            hasNoteStaged,\n            isIntaking);\n\n    Logger.recordOutput(\n        "RobotState/Pose Data/Estimated Pose", poseEstimator.getEstimatedPosition());\n    Logger.recordOutput("RobotState/Pose Data/Odometry Pose", odometry.getPoseMeters());\n    Logger.recordOutput("RobotState/Pose Data/Heading Offset", headingOffset);\n    Logger.recordOutput(\n        "RobotState/Pose Data/Effective Speaker Aiming Pose",\n        new Pose2d(effectiveSpeakerAimingTranslation, speakerRobotAngle));\n    Logger.recordOutput(\n        "RobotState/Pose Data/Effective Amp Aiming Pose",\n        new Pose2d(effectiveAmpAimingTranslation, ampRobotAngle));\n    Logger.recordOutput(\n        "RobotState/Pose Data/Effective Feed Aiming Pose",\n        new Pose2d(effectiveAmpAimingTranslation, feedRobotAngle));\n    Logger.recordOutput(\n        "RobotState/Pose Data/Effective Distance To Speaker", effectiveDistanceToSpeaker);\n    Logger.recordOutput("RobotState/Pose Data/Effective Distance To Amp", effectiveDistanceToAmp);\n\n    Logger.recordOutput(\n        "RobotState/Control Data/Speaker Robot Angle", controlData.speakerRobotAngle());\n    Logger.recordOutput("RobotState/Control Data/Speaker Arm Angle", controlData.speakerArmAngle());\n    Logger.recordOutput(\n        "RobotState/Control Data/Speaker Radial Velocity", controlData.speakerRadialVelocity());\n    Logger.recordOutput(\n        "RobotState/Control Data/Amp Radial Velocity", controlData.ampRadialVelocity());\n    Logger.recordOutput("RobotState/Control Data/Feed Robot Angle", controlData.feedRobotAngle());\n    Logger.recordOutput(\n        "RobotState/Control Data/Feed Radial Velocity", controlData.feedRadialVelocity());\n    Logger.recordOutput("RobotState/Control Data/Feed Arm Angle", controlData.feedArmAngle());\n  }\n'})}),"\n",(0,a.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,a.jsxs)(t.p,{children:["See ",(0,a.jsx)(t.a,{href:"https://github.com/Team-190/2k24-Robot-Code/blob/main/src/main/java/frc/robot/RobotState.java",children:"Snapback and Whiplash RobotState"})]})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>r,x:()=>s});var n=o(6540);const a={},i=n.createContext(a);function r(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);