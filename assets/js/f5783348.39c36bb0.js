"use strict";(self.webpackChunkcode_standard=self.webpackChunkcode_standard||[]).push([[327],{4925:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"ROBOT_CODE_OVERVIEW","title":"FRC Code Overview","description":"The Command-Based Programming paradigm in FRC is a design pattern that structures robot code into highly modular and testable units. By discretizing robot hardware through subsystems, it becomes possible to define complex behaviors far easier than if all mechanism code was in one place.","source":"@site/docs/ROBOT_CODE_OVERVIEW.md","sourceDirName":".","slug":"/ROBOT_CODE_OVERVIEW","permalink":"/190-Robot-Code-Standards/ROBOT_CODE_OVERVIEW","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Global Standards","permalink":"/190-Robot-Code-Standards/GLOBAL_STANDARDS"},"next":{"title":"AdvantageKit Standards","permalink":"/190-Robot-Code-Standards/ADVANTAGEKIT_STANDARDS"}}');var a=s(4848),r=s(8453);const i={},o="FRC Code Overview",d={},l=[{value:"The Command-Based Programming Model",id:"the-command-based-programming-model",level:2},{value:"The Role of Hardware Abstraction",id:"the-role-of-hardware-abstraction",level:2},{value:"Benefits of Subsystem Hardware Abstraction",id:"benefits-of-subsystem-hardware-abstraction",level:2}];function c(e){const t={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"frc-code-overview",children:"FRC Code Overview"})}),"\n",(0,a.jsx)(t.p,{children:"The Command-Based Programming paradigm in FRC is a design pattern that structures robot code into highly modular and testable units. By discretizing robot hardware through subsystems, it becomes possible to define complex behaviors far easier than if all mechanism code was in one place."}),"\n",(0,a.jsx)(t.h2,{id:"the-command-based-programming-model",children:"The Command-Based Programming Model"}),"\n",(0,a.jsx)(t.p,{children:"Command-Based Programming organizes robot code into two main components:"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Subsystems"})," Represent the physical mechanisms of the robot (e.g., drivetrain, flywheels, arm, elevator). Subsystems encapsulate the hardware and define a set of capabilities that other parts of the robot can interact with."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Commands"})," Represent actions or sequences of actions that the robot performs. Commands control subsystems, but they are not directly tied to specific hardware implementations."]}),"\n",(0,a.jsx)(t.p,{children:"This separation of concerns makes the code easier to understand, extend, and debug."}),"\n",(0,a.jsx)(t.h2,{id:"the-role-of-hardware-abstraction",children:"The Role of Hardware Abstraction"}),"\n",(0,a.jsx)(t.p,{children:"Hardware abstraction is the practice of creating an interface layer between the subsystem logic and the actual hardware. Instead of directly interacting with sensors and actuators, the subsystem interacts with a hardware abstraction layer. This enables:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Simulation of Robot Behavior:"})," Simulation tools, such as WPILib's built-in physics simulation, allow for testing robot code without access to physical hardware. By using hardware abstraction, it becomes possible to replace the physical hardware implementation with a simulated version that mimics the behavior of the real hardware."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Unit Testing:"})," Hardware abstraction decouples subsystem logic from specific hardware implementations. This decoupling allows for mock or dummy hardware implementations to test subsystem and command functionality in isolation. This is especially useful for automated testing, ensuring robot code behaves correctly under various scenarios before running on a robot."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Easy Adaptation to Hardware Changes:"})," Robots often evolve, with components being swapped or upgraded during development or between seasons. With hardware abstraction, adapting to new hardware becomes straightforward, by replacing the underlying implementation while leaving subsystem logic and commands untouched."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Structuring Subsystems for Hardware Abstraction\nSubsystems are designed to define the robot's functional behavior without being tied to specific hardware. This is achieved by separating the following layers:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Hardware Interface:"})," The hardware interface defines a contract for how the subsystem interacts with its hardware components. It specifies what the subsystem needs to do (e.g., set motor speeds, read sensor values) but not how these actions are implemented."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Physical Hardware Implementation:"})," The physical hardware implementation fulfills the hardware interface by directly interacting with the robot's sensors and actuators (e.g., motor controllers, encoders, gyros). This layer depends on libraries like WPILib to interact with physical hardware."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Simulated Hardware Implementation:"})," The simulated hardware implementation provides the same interface but replaces physical interactions with computed or virtual behavior. This layer allows testing in simulation or environments without access to a robot."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Subsystem Logic:"})," The subsystem logic defines the functional capabilities of the robot component (e.g., driving forward, turning). This layer uses the hardware interface and is agnostic to whether the hardware is real or simulated."]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"benefits-of-subsystem-hardware-abstraction",children:"Benefits of Subsystem Hardware Abstraction"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Seamless Transition Between Environments:"})," With hardware abstraction, the same subsystem logic and commands can be used in both physical and simulated environments. This is particularly valuable for debugging and iterative development when access to a robot is limited."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Improved Maintainability:"})," Subsystems only rely on the hardware interface, allowing changes to hardware details to be made in one place. This reduces the ripple effects of hardware changes throughout the codebase."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Enhanced Code Reusability:"})," Subsystems and commands become portable across projects and robots. As long as the hardware interface remains consistent, the same logic can be reused regardless of the underlying hardware."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Simplified Debugging:"})," Simulated hardware implementations can provide detailed logs or visualizations of the robot's behavior, helping to identify issues that may not be apparent with physical hardware."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>i,x:()=>o});var n=s(6540);const a={},r=n.createContext(a);function i(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);